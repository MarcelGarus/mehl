### The Mehl Core Library
#
# Welcome! This library offers functionality that is useful in almost all Mehl
# programs. It's well-commented so that you can read it from top to bottom like
# a book.
#
# In Mehl, `✨` is the entry point for the Mehl interpreter to offer various
# features that would be impossible or impractical to implement directly in Mehl
# itself. Calls to these magic primitives have the following form:
# `(primitive-name, argument) ✨`

## Fibers
#
# Fibers are concurrent execution strands. They are comparable to the threads
# of an operating system, but much more lightweight.

[(:panic, .) ✨] -> panic
[(:todo, "Todo: This part of the program is missing.") panic] -> ...

## Ambients
#
# Fibers can have ambients, which are global, dynamic variables that don't need
# to be passed into functions explicitly.

[(:get-ambient, .) ✨] -> ambient

## Channels
#
# Fibers can communicate using channels, which are like streams of values that
# flow between them. When creating such a channel, the VM gives you two ends:
# One for sending messages and one for receiving them.

[(:channel, .) ✨] -> create-channel
[(:send, .) ✨] -> send
[(:receive, .) ✨] -> receive

## Int

[(:add, .) ✨] -> +
# [(:subtract, .) ✨] -> Int.-
# [(:multiply, .) ✨] -> Int.*
# [(:divide, .) ✨] -> Int./
# [(:modulo, .) ✨] -> Int.mod

## Lists or tuples

[(:get-item, .) ✨] -> get-item

## Code

# [(:run, .) ✨] -> run
# [(:repeat, .) ✨] -> repeat
# [(:loop, .) ✨] -> loop

## Todo: Bool
#
# Boolean values (or bools for short) encode truthfulness. Only two bools exist:
# `:true` and `:false`.

## Input and Output

[:stdin ambient] -> stdin
[:stdout ambient] -> stdout
[(stdout, .) send] -> print
[stdin receive] -> read

## Todo: Time

## Todo
# - bignums
# - match
# - more primitives
#  - =, !=
#  - Int.+, Int.-, Int.*, Int./, Int.mod, Int.pow, Int.neg, Int.>, Int.>=, Int.<, Int.<=
#  - String.bytes, String.chars
#  - Map.get, Map.insert, Map.join, Map.keys
#  - List.get, List.len
#  - Fiber.new, Fiber.run, Fiber.spawn, Fiber.kill, Fiber.set-priority
#  - wait
#  - Channel.new
# - fibers
# - better Core library
#  - Panic: assert
#  - Bool: Bool.not, Bool.&, Bool.|, Bool.=>
#  - Maybe: Maybe.unwrap, Maybe.map
#  - Result: Result.unwrap, Result.map, Result.map-error
#  - Iter: Iter.next
#  - Units: seconds, meters, milli, micro, kilo, mega, giga, tera, peta, kibi, mibi, gibi, tibi, pibi
#  - Test
# - support including modules
# - in the VM, use actual pointers instead of a HashMap
# - make stack entries more compact
# - optimize LIR
# - string interpolation
# - sets
# - merging of maps
# - side-effect-ful
#  - Stdout
#  - Stdin
#  - Http.get
#  - Random
# - wrong-usage
# - LSP
# - Automatic property-based testing

##########

# (:get-item, "Returns the nth item from a list. Usage: (my-list, 0) get-item", [ (:get-item) ✨ ]) fun

# There is no built-in concept of types. Instead, arbitrary code can determine
# whether something is a valid input and output of a function.

#{ :name, :identical?, :in, Any, :out, Any, :body, [(:identical, .) ✨] } fun
#{ :name, Unit?, [(:, .) (:identical, .) ✨] } fun
#{ :name, :type, :in, Any, :out, Any, :body, [(:type, .) ✨] } fun
#{ :name, :Int, :in, Any, :out, Any, :body, [[:true]] } fun # (. type, :int) identical?

#(:int.+, int? list?, int?, "Adds numbers.", [:add-ints ✨]) fun

#(:string?, any?, [[(. type, :string) identical]]) fun
#(:symbol?, any?, [[(. type, :symbol) identical]]) fun
#(:list?, any?, [[(. type, :list) identical]]) fun
#(:map?, any?, [[(. type, :map) identical]]) fun
#(:exactly?, any? [:a[(.) identical]])
#(:+, list?, [(:add-numbers, .) ✨]) fun # TODO
