## The Mehl Core Library

# Welcome! This library is implicitly included at the start of every Mehl run.
# There are comments throughout so that you can read it from top to bottom like
# a book.

# In Mehl, `✨` is the entry point for the Mehl interpreter to offer various
# features that would be impossible or impractical to implement directly in Mehl
# itself. Calls to these magic primitives have the following form:
# `(primitive-name, args) ✨`
# The primitive entry point `✨` is automatically made available before any
# code runs. Note that you can loose access to `✨`, for example by redefining
# it to be something else.

## Keywords to bind functions and code

# In Mehl, there is no distinction between variables or functions – variables
# are just functions which always return the same result. You can use `fun` to
# define a function, or `let` if you already have a value. Both of these
# keywords are themselves functions.
# How can this possibly work? Each function has an *export level*, which defines
# how often it should be exported from the current function call. The default
# export level is 0, but the `:fun` primitive accepts an arbitrary export level.
# That means it's possible to define functions that define functions in the
# surrounding scope when they're used!

{ :name, :let, :docs, "Defines a new value. Usage: (:a, 5) let", :body, [
  (:let, { :name, (:name, :value), :value, . }) ✨
  (:let, { :name, name, :value, value, :export-level, 1 }) ✨
] } (:fun, .) ✨

{ :name, :fun, :docs, "Defines a new function. Usage: (:foo, docs, [1]) fun", :body, [
  ((:name, :docs, :body), .) let
  (:fun, { :name, name, :docs, docs, :body, body, :export-level, 1 }) ✨
] } (:fun, .) ✨

# To define something publically, `pub-let` and `pub-fun` are useful. They have
# an export level of 2, which means that if you use them to define something in
# a scope and that scope gets imported somewhere else, the functions are also
# imported:
#
# ```
# [
#   (:foo, "A foo.", ["Hello, world!" print]) pub-fun
#   (:bar, 5) pub-let
# ] use
#
# foo # Prints "Hello, world!"
# ```

(:pub-let, "Defines a new public value that is available if the current scope is imported somewhere else.", [
  ((:name, :value), .) let
  (:let, { :name, name, :value, value, :export-level, 2 }) ✨
]) fun

(:pub-fun, "Defines a new public function that is available if the current scope is imported somewhere else.", [
  ((:name, :docs, :body), .) let
  (:fun, { :name, name, :docs, docs, :body, body, :export-level, 2 }) ✨
]) fun

(:use, "Executes code and then imports functions that it exported.", [
  (:use, .) ✨ # Runs the code and makes functions available in this scope.
  (:export-all, :) ✨ # Increases the export level of all functions in this scope.
]) fun

## Control flow

(:match, "Matches over conditions.", [(:match, .) ✨]) fun
(:wait, "Waits an amount of seconds.", [(:wait, .) ✨]) fun
(:loop, "Executes code again and again.", [(:loop, .) ✨]) fun
# (:run, "Executes code.", [(:run, .) ✨]) fun
(:panic, "Crashes the program.", [(:panic, .) ✨]) fun
(:..., "Crashes the program because some part of it is not implemented yet.", [
  "Todo: A part of the program is not yet implemented." panic
]) fun

## Input and Output

(:print, "Prints to stdout.", [(:print, .) ✨]) fun

###

# TODO
# * bools
# * logic
# * run
# * maybe
# * math
# * output
# * input
# * iterate
# * random
# * units
# * fibers
# * http get
# * FFI
# * wrong-usage
# * propagate-wrong-usage
# * channels
# * ambients

# (:get-item, "Returns the nth item from a list. Usage: (my-list, 0) get-item", [ (:get-item) ✨ ]) fun

# There is no built-in concept of types. Instead, arbitrary code can determine
# whether something is a valid input and output of a function.

#{ :name, :identical?, :in, Any, :out, Any, :body, [(:identical, .) ✨] } fun
#{ :name, Unit?, [(:, .) (:identical, .) ✨] } fun
#{ :name, :type, :in, Any, :out, Any, :body, [(:type, .) ✨] } fun
#{ :name, :Int, :in, Any, :out, Any, :body, [[:true]] } fun # (. type, :int) identical?

#(:int.+, int? list?, int?, "Adds numbers.", [:add-ints ✨]) fun

#(:string?, any?, [[(. type, :string) identical]]) fun
#(:symbol?, any?, [[(. type, :symbol) identical]]) fun
#(:list?, any?, [[(. type, :list) identical]]) fun
#(:map?, any?, [[(. type, :map) identical]]) fun
#(:exactly?, any? [:a[(.) identical]])
#(:+, list?, [(:add-numbers, .) ✨]) fun # TODO
