# Welcome to the Mehl core library!
# This library is implicitly included at the start of every Mehl run. There are
# comments throughout so that you can read it from top to bottom like a book.

# In Mehl, `✨` is the entry point for the Mehl interpreter to offer various
# features that would be impossible or impractical to implement directly in Mehl
# itself. Calls to these magic primitives have the following form:
# `(primitive-name, args) ✨`

{ :name, :fun, :docs, "Defines a new function.", :body, [ (:fun-and-export, .) ✨ ] } (:fun, .) ✨
{ :name, :print, :docs, "Prints to stdout.", :body, [(:print, .) ✨] } fun
{ :name, :wait, :docs, "Waits an amount of seconds.", :body, [(:wait, .) ✨] } fun
{ :name, :run, :docs, "Executes code.", :body, [(:run, .) ✨] } fun
{ :name, :loop, :docs, "Executes code again and again.", :body, [(:loop, .) ✨] } fun
{ :name, :use, :docs, "Imports functions from a scope.", :body, [(:run-and-import, .) ✨] } fun

#####

# There is no built-in concept of types. Instead, arbitrary code can determine
# whether something is a valid input and output of a function.

#{ :name, :identical?, :in, Any, :out, Any, :body, [(:identical, .) ✨] } fun
#{ :name, Unit?, [(:, .) (:identical, .) ✨] } fun
#{ :name, :type, :in, Any, :out, Any, :body, [(:type, .) ✨] } fun
#{ :name, :Int, :in, Any, :out, Any, :body, [[:true]] } fun # (. type, :int) identical?

#(:int.+, int? list?, int?, "Adds numbers.", [:add-ints ✨]) fun

#(:string?, any?, [[(. type, :string) identical]]) fun
#(:symbol?, any?, [[(. type, :symbol) identical]]) fun
#(:list?, any?, [[(. type, :list) identical]]) fun
#(:map?, any?, [[(. type, :map) identical]]) fun
#(:exactly?, any? [:a[(.) identical]])
#(:+, list?, [(:add-numbers, .) ✨]) fun # TODO
